<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Audio Call</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #f0f2f5; padding: 20px; }
        .container { max-width: 800px; margin: 0 auto; }
        .header { background: #667eea; color: white; padding: 20px; border-radius: 10px 10px 0 0; }
        .content { background: white; padding: 20px; border-radius: 0 0 10px 10px; }
        .section { margin-bottom: 20px; }
        h3 { margin-bottom: 10px; color: #333; }
        input, button { padding: 10px; margin: 5px 0; border-radius: 5px; border: 1px solid #ddd; }
        button { background: #667eea; color: white; border: none; cursor: pointer; }
        button:hover { background: #5a67d8; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .hidden { display: none; }
        .status { padding: 10px; background: #f8f9fa; border-radius: 5px; margin: 10px 0; }
        .error { color: #e53e3e; }
        .success { color: #38a169; }
        .controls { display: flex; gap: 10px; flex-wrap: wrap; }
        .room-info { background: #e6f7ff; padding: 10px; border-radius: 5px; }
        .log { background: #f8f9fa; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé§ WebRTC Audio Call</h1>
            <p>Simple peer-to-peer audio calling</p>
        </div>
        
        <div class="content">
            <!-- Server Connection -->
            <div class="section">
                <h3>üîó Server Connection</h3>
                <div class="controls">
                    <input type="text" id="serverUrl" value="ws://localhost:8080" style="flex: 1;">
                    <button onclick="connectToServer()" id="connectBtn">Connect</button>
                    <button onclick="disconnectFromServer()" id="disconnectBtn" class="hidden">Disconnect</button>
                </div>
                <div id="serverStatus" class="status">Not connected</div>
            </div>
            
            <!-- Room Management -->
            <div class="section">
                <h3>üè† Room Management</h3>
                <div class="controls">
                    <input type="text" id="roomId" placeholder="Enter room ID" style="flex: 1;">
                    <button onclick="createRoom()" id="createRoomBtn">Create Room</button>
                    <button onclick="joinRoom()" id="joinRoomBtn">Join Room</button>
                    <button onclick="leaveRoom()" id="leaveRoomBtn" class="hidden">Leave Room</button>
                </div>
                <div id="roomStatus" class="status">Not in a room</div>
            </div>
            
            <!-- Call Controls -->
            <div class="section">
                <h3>üìû Call Controls</h3>
                <div class="controls">
                    <button onclick="startCall()" id="startCallBtn" class="hidden">Start Call</button>
                    <button onclick="answerCall()" id="answerCallBtn" class="hidden">Answer Call</button>
                    <button onclick="hangupCall()" id="hangupBtn" class="hidden">Hang Up</button>
                </div>
                <div id="callStatus" class="status">Ready</div>
            </div>
            
            <!-- Room Information -->
            <div id="roomInfo" class="room-info hidden">
                <h3>üë• Room Info</h3>
                <p>Room ID: <strong id="currentRoomId"></strong></p>
                <p>Clients: <span id="roomClients"></span></p>
                <p>Your Role: <span id="userRole"></span></p>
            </div>
            
            <!-- Log -->
            <div class="section">
                <h3>üìù Log</h3>
                <div id="log" class="log"></div>
            </div>
        </div>
    </div>

    <audio id="ringtone" loop hidden>
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-phone-call-ringing-1007.mp3" type="audio/mpeg">
    </audio>
    <audio id="remoteAudio" autoplay hidden></audio>

    <script>
        class WebRTCAudioCall {
            constructor() {
                this.websocket = null;
                this.peerConnection = null;
                this.localStream = null;
                this.remoteStream = new MediaStream();
                this.roomId = null;
                this.clientId = null;
                this.isCaller = false;
                this.isInCall = false;
                
                this.ringtone = document.getElementById('ringtone');
                this.remoteAudio = document.getElementById('remoteAudio');
                this.remoteAudio.srcObject = this.remoteStream;
                
                this.logMessages = [];
                this.updateLog('App initialized');
            }
            
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                this.logMessages.push(logEntry);
                
                // Keep only last 20 messages
                if (this.logMessages.length > 20) {
                    this.logMessages.shift();
                }
                
                // Update log display
                const logElement = document.getElementById('log');
                logElement.innerHTML = this.logMessages.join('<br>');
                logElement.scrollTop = logElement.scrollHeight;
                
                console.log(`[${type.toUpperCase()}] ${message}`);
            }
            
            updateLog(message) {
                this.log(message);
            }
            
            updateStatus(elementId, message, type = 'info') {
                const element = document.getElementById(elementId);
                element.textContent = message;
                element.className = 'status ' + type;
            }
            
            async connectToServer() {
                const serverUrl = document.getElementById('serverUrl').value;
                
                if (!serverUrl) {
                    this.updateStatus('serverStatus', 'Please enter a server URL', 'error');
                    return;
                }
                
                this.updateStatus('serverStatus', 'Connecting...');
                this.log(`Connecting to ${serverUrl}`);
                
                try {
                    this.websocket = new WebSocket(serverUrl);
                    
                    this.websocket.onopen = () => {
                        this.updateStatus('serverStatus', 'Connected', 'success');
                        this.log('WebSocket connected successfully');
                        
                        document.getElementById('connectBtn').classList.add('hidden');
                        document.getElementById('disconnectBtn').classList.remove('hidden');
                        document.getElementById('createRoomBtn').disabled = false;
                        document.getElementById('joinRoomBtn').disabled = false;
                    };
                    
                    this.websocket.onerror = (error) => {
                        this.updateStatus('serverStatus', 'Connection error', 'error');
                        this.log(`WebSocket error: ${error}`);
                    };
                    
                    this.websocket.onclose = () => {
                        this.updateStatus('serverStatus', 'Disconnected');
                        this.log('WebSocket disconnected');
                        
                        document.getElementById('connectBtn').classList.remove('hidden');
                        document.getElementById('disconnectBtn').classList.add('hidden');
                        document.getElementById('createRoomBtn').disabled = true;
                        document.getElementById('joinRoomBtn').disabled = true;
                        
                        // Reset everything
                        this.reset();
                    };
                    
                    this.websocket.onmessage = (event) => {
                        this.handleServerMessage(event.data);
                    };
                    
                } catch (error) {
                    this.updateStatus('serverStatus', `Connection failed: ${error.message}`, 'error');
                    this.log(`Connection error: ${error.message}`);
                }
            }
            
            disconnectFromServer() {
                if (this.websocket) {
                    this.websocket.close();
                    this.websocket = null;
                }
                
                this.updateStatus('serverStatus', 'Disconnected');
                this.log('Disconnected from server');
            }
            
            handleServerMessage(message) {
                try {
                    const data = JSON.parse(message);
                    this.log(`Received: ${data.type}`);
                    
                    switch (data.type) {
                        case 'welcome':
                            this.clientId = data.clientId;
                            this.updateLog(`Connected as ${this.clientId}`);
                            break;
                            
                        case 'room-created':
                            this.roomId = data.roomId;
                            this.isCaller = true;
                            this.updateRoomUI();
                            this.updateLog(`Room created: ${data.roomId}`);
                            break;
                            
                        case 'room-joined':
                            this.roomId = data.roomId;
                            this.isCaller = false;
                            this.updateRoomUI();
                            this.updateLog(`Joined room: ${data.roomId}`);
                            break;
                            
                        case 'peer-joined':
                            this.updateLog(`Peer joined: ${data.clientId}`);
                            if (this.isCaller) {
                                document.getElementById('startCallBtn').classList.remove('hidden');
                            }
                            break;
                            
                        case 'peer-disconnected':
                            this.updateLog(`Peer disconnected: ${data.clientId}`);
                            if (this.isInCall) {
                                this.hangupCall();
                            }
                            break;
                            
                        case 'offer':
                            this.handleOffer(data);
                            break;
                            
                        case 'answer':
                            this.handleAnswer(data);
                            break;
                            
                        case 'candidate':
                            this.handleCandidate(data);
                            break;
                            
                        case 'hangup':
                            this.handleHangup(data);
                            break;
                            
                        case 'error':
                            this.updateLog(`Error: ${data.message}`, 'error');
                            break;
                    }
                } catch (error) {
                    this.log(`Error handling message: ${error.message}`, 'error');
                }
            }
            
            updateRoomUI() {
                document.getElementById('currentRoomId').textContent = this.roomId;
                document.getElementById('roomInfo').classList.remove('hidden');
                document.getElementById('leaveRoomBtn').classList.remove('hidden');
                document.getElementById('createRoomBtn').classList.add('hidden');
                document.getElementById('joinRoomBtn').classList.add('hidden');
                
                this.updateStatus('roomStatus', `In room: ${this.roomId}`, 'success');
            }
            
            async createRoom() {
                if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
                    this.updateStatus('roomStatus', 'Not connected to server', 'error');
                    return;
                }
                
                const roomIdInput = document.getElementById('roomId').value;
                const roomId = roomIdInput || 'default-room';
                
                this.websocket.send(JSON.stringify({
                    type: 'create-room',
                    roomId: roomId
                }));
                
                this.updateLog(`Creating room: ${roomId}`);
            }
            
            async joinRoom() {
                if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
                    this.updateStatus('roomStatus', 'Not connected to server', 'error');
                    return;
                }
                
                const roomId = document.getElementById('roomId').value;
                
                if (!roomId) {
                    this.updateStatus('roomStatus', 'Please enter a room ID', 'error');
                    return;
                }
                
                this.websocket.send(JSON.stringify({
                    type: 'join-room',
                    roomId: roomId
                }));
                
                this.updateLog(`Joining room: ${roomId}`);
            }
            
            leaveRoom() {
                if (this.roomId) {
                    this.updateLog(`Leaving room: ${this.roomId}`);
                    this.roomId = null;
                    
                    document.getElementById('roomInfo').classList.add('hidden');
                    document.getElementById('leaveRoomBtn').classList.add('hidden');
                    document.getElementById('createRoomBtn').classList.remove('hidden');
                    document.getElementById('joinRoomBtn').classList.remove('hidden');
                    
                    this.updateStatus('roomStatus', 'Not in a room');
                }
            }
            
            async startCall() {
                try {
                    this.updateLog('Starting call...');
                    
                    // Get microphone access
                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: 48000,
                            channelCount: 1
                        },
                        video: false
                    });
                    
                    // Create peer connection
                    this.peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' }
                        ]
                    });
                    
                    // Add local tracks
                    this.localStream.getTracks().forEach(track => {
                        this.peerConnection.addTrack(track, this.localStream);
                    });
                    
                    // Handle remote tracks
                    this.peerConnection.ontrack = (event) => {
                        this.remoteStream.addTrack(event.track);
                        this.remoteAudio.play().catch(e => console.log('Audio play error:', e));
                    };
                    
                    // Handle ICE candidates
                    this.peerConnection.onicecandidate = (event) => {
                        if (event.candidate && this.websocket) {
                            this.websocket.send(JSON.stringify({
                                type: 'candidate',
                                candidate: event.candidate
                            }));
                        }
                    };
                    
                    // Create and send offer
                    const offer = await this.peerConnection.createOffer();
                    await this.peerConnection.setLocalDescription(offer);
                    
                    this.websocket.send(JSON.stringify({
                        type: 'offer',
                        sdp: offer.sdp
                    }));
                    
                    this.isInCall = true;
                    document.getElementById('startCallBtn').classList.add('hidden');
                    document.getElementById('hangupBtn').classList.remove('hidden');
                    
                    this.updateStatus('callStatus', 'Calling...');
                    this.updateLog('Call started, waiting for answer');
                    
                } catch (error) {
                    this.updateLog(`Error starting call: ${error.message}`, 'error');
                }
            }
            
            async handleOffer(data) {
                this.updateLog('Received offer');
                
                // Show answer button
                document.getElementById('answerCallBtn').classList.remove('hidden');
                
                // Store the offer
                this.receivedOffer = data;
                
                this.updateStatus('callStatus', 'Incoming call!');
                
                // Play ringing sound
                this.ringtone.play().catch(e => console.log('Ringtone error:', e));
            }
            
            async answerCall() {
                try {
                    this.ringtone.pause();
                    this.updateLog('Answering call...');
                    
                    // Get microphone access
                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: 48000,
                            channelCount: 1
                        },
                        video: false
                    });
                    
                    // Create peer connection
                    this.peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' }
                        ]
                    });
                    
                    // Add local tracks
                    this.localStream.getTracks().forEach(track => {
                        this.peerConnection.addTrack(track, this.localStream);
                    });
                    
                    // Handle remote tracks
                    this.peerConnection.ontrack = (event) => {
                        this.remoteStream.addTrack(event.track);
                        this.remoteAudio.play().catch(e => console.log('Audio play error:', e));
                    };
                    
                    // Handle ICE candidates
                    this.peerConnection.onicecandidate = (event) => {
                        if (event.candidate && this.websocket) {
                            this.websocket.send(JSON.stringify({
                                type: 'candidate',
                                candidate: event.candidate
                            }));
                        }
                    };
                    
                    // Set remote description from offer
                    await this.peerConnection.setRemoteDescription(
                        new RTCSessionDescription({ type: 'offer', sdp: this.receivedOffer.sdp })
                    );
                    
                    // Create and send answer
                    const answer = await this.peerConnection.createAnswer();
                    await this.peerConnection.setLocalDescription(answer);
                    
                    this.websocket.send(JSON.stringify({
                        type: 'answer',
                        sdp: answer.sdp
                    }));
                    
                    this.isInCall = true;
                    document.getElementById('answerCallBtn').classList.add('hidden');
                    document.getElementById('hangupBtn').classList.remove('hidden');
                    
                    this.updateStatus('callStatus', 'Call connected!');
                    this.updateLog('Call answered and connected');
                    
                } catch (error) {
                    this.updateLog(`Error answering call: ${error.message}`, 'error');
                }
            }
            
            async handleAnswer(data) {
                if (this.peerConnection) {
                    await this.peerConnection.setRemoteDescription(
                        new RTCSessionDescription({ type: 'answer', sdp: data.sdp })
                    );
                    
                    this.updateStatus('callStatus', 'Call connected!');
                    this.updateLog('Call connected successfully');
                }
            }
            
            async handleCandidate(data) {
                if (this.peerConnection && data.candidate) {
                    try {
                        await this.peerConnection.addIceCandidate(
                            new RTCIceCandidate(data.candidate)
                        );
                    } catch (error) {
                        console.log('Error adding ICE candidate:', error);
                    }
                }
            }
            
            handleHangup(data) {
                this.updateLog('Received hangup from peer');
                this.hangupCall();
            }
            
            hangupCall() {
                this.updateLog('Hanging up call...');
                
                // Send hangup to other peer
                if (this.websocket && this.roomId) {
                    this.websocket.send(JSON.stringify({
                        type: 'hangup'
                    }));
                }
                
                // Close peer connection
                if (this.peerConnection) {
                    this.peerConnection.close();
                    this.peerConnection = null;
                }
                
                // Stop local stream
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                    this.localStream = null;
                }
                
                // Stop ringing
                this.ringtone.pause();
                this.ringtone.currentTime = 0;
                
                // Reset call UI
                this.isInCall = false;
                document.getElementById('startCallBtn').classList.remove('hidden');
                document.getElementById('answerCallBtn').classList.add('hidden');
                document.getElementById('hangupBtn').classList.add('hidden');
                
                this.updateStatus('callStatus', 'Call ended');
                this.updateLog('Call ended');
            }
            
            reset() {
                this.roomId = null;
                this.isCaller = false;
                this.isInCall = false;
                
                if (this.peerConnection) {
                    this.peerConnection.close();
                    this.peerConnection = null;
                }
                
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                    this.localStream = null;
                }
                
                this.ringtone.pause();
                this.ringtone.currentTime = 0;
                
                // Reset UI
                document.getElementById('roomInfo').classList.add('hidden');
                document.getElementById('leaveRoomBtn').classList.add('hidden');
                document.getElementById('createRoomBtn').classList.remove('hidden');
                document.getElementById('joinRoomBtn').classList.remove('hidden');
                document.getElementById('startCallBtn').classList.add('hidden');
                document.getElementById('answerCallBtn').classList.add('hidden');
                document.getElementById('hangupBtn').classList.add('hidden');
                
                this.updateStatus('roomStatus', 'Not in a room');
                this.updateStatus('callStatus', 'Ready');
            }
        }
        
        // Create global instance
        let audioCall = new WebRTCAudioCall();
        
        // Global functions for button clicks
        function connectToServer() {
            audioCall.connectToServer();
        }
        
        function disconnectFromServer() {
            audioCall.disconnectFromServer();
        }
        
        function createRoom() {
            audioCall.createRoom();
        }
        
        function joinRoom() {
            audioCall.joinRoom();
        }
        
        function leaveRoom() {
            audioCall.leaveRoom();
        }
        
        function startCall() {
            audioCall.startCall();
        }
        
        function answerCall() {
            audioCall.answerCall();
        }
        
        function hangupCall() {
            audioCall.hangupCall();
        }
    </script>
</body>
</html>
